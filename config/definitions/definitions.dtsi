// shortcut definitions

#include "key_positions.dtsi"

/ {
  compatible = "zmk,bindings";
  #define LONG_TIMEOUT_MS 100
  #define NORMAL_LAYERS ALP NUM SYM CRD
  #define NORMAL_LAYERS_MAC 3 4
  #define NORMAL_LAYERS_WIN 5 6
  #define LOCK_LAYER 7

  behaviors {
    skq: sticky_key_quick_release {
      compatible = "zmk,behavior-sticky-key";
      label = "STICKY_KEY_QUICK_RELEASE";
      #binding-cells = <1>;
      bindings = <&kp>;
      release-after-ms = <1000>;
      quick-release;
    };

    skl: sticky_key_long_pressed {
      compatible = "zmk,behavior-sticky-key";
      label = "STICKY_KEY_QUICK_RELEASE";
      #binding-cells = <1>;
      bindings = <&kp>;
      release-after-ms = <10000>;
    };
  };
};

#define HOLD_TAP_BEHAVIORS(NAME, HOLD_BEHAVIOR, TAP_BEHAVIOR) \
/ {\
  behaviors {\
    ht_##NAME: ht_behavior_##NAME {\
      compatible = "zmk,behavior-hold-tap";\
      label = str(hold_tap_ht_behavior_##NAME);\
      #binding-cells = <2>;\
      flavor = "hold-preferred";\
      retro-tap;\
      tapping-term-ms = <280>;\
      bindings = <HOLD_BEHAVIOR>, <TAP_BEHAVIOR>;\
    };\
  };\
};


#define COMBO(NAME, BINDINGS, KEYPOS) \
  / {\
    combos {\
      compatible = "zmk,combos";\
      combo_##NAME { \
        bindings = <BINDINGS>; \
        key-positions = <KEYPOS>; \
        layers = <NORMAL_LAYERS>; \
      };\
    };\
  };

#define COMBO_LONG(NAME, BINDINGS, KEYPOS) \
  / {\
    combos {\
      compatible = "zmk,combos";\
      combo_##NAME { \
        bindings = <BINDINGS>; \
        key-positions = <KEYPOS>; \
        layers = <NORMAL_LAYERS>; \
        timeout-ms = <LONG_TIMEOUT_MS>; \
      };\
    };\
  };

#define COMBO_LONG_MAC(NAME, BINDINGS, KEYPOS) \
  / {\
    combos {\
      compatible = "zmk,combos";\
      combo_##NAME { \
        bindings = <BINDINGS>; \
        key-positions = <KEYPOS>; \
        layers = <NORMAL_LAYERS NORMAL_LAYERS_MAC>; \
        timeout-ms = <LONG_TIMEOUT_MS>; \
      };\
    };\
  };

#define COMBO_LONG_WIN(NAME, BINDINGS, KEYPOS) \
  / {\
    combos {\
      compatible = "zmk,combos";\
      combo_##NAME { \
        bindings = <BINDINGS>; \
        key-positions = <KEYPOS>; \
        layers = <NORMAL_LAYERS NORMAL_LAYERS_WIN>; \
        timeout-ms = <LONG_TIMEOUT_MS>; \
      };\
    };\
  };

#define COMBO_LAYER(NAME, BINDINGS, KEYPOS, LAYERS) \
  / {\
    combos {\
      compatible = "zmk,combos";\
      combo_##NAME { \
        bindings = <BINDINGS>; \
        key-positions = <KEYPOS>; \
        layers = <LAYERS>; \
      };\
   };\
  };

#define str(s) #s
#define MACRO(NAME, BINDINGS) \
  / { \
    macros { \
      macro_##NAME: macro_##NAME { \
        compatible = "zmk,behavior-macro"; \
        label = str(macro_##NAME); \
        #binding-cells = <0>; \
        wait-ms = <0>; \
        tap-ms = <10>; \
        bindings = <BINDINGS>; \
      };\
    };\
  };

#define CHORD(NAME, BINDINGS, KEYPOS) \
  MACRO(chord_##NAME, BINDINGS) \
  COMBO(chord_##NAME, &macro_chord_##NAME, KEYPOS) \

#define CHORD_LAYER(NAME, BINDINGS, KEYPOS, LAYER) \
  MACRO(chord_##NAME, BINDINGS) \
  COMBO_LAYER(chord_##NAME, &macro_chord_##NAME, KEYPOS, LAYER) \

#define MOD_MORPH(NAME, BINDING_PURE, BINDING_MODED, MODS) \
/ { \
    behaviors { \
         mm_##NAME: mod_morph_##NAME {\
            compatible = "zmk,behavior-mod-morph";\
            label = str(mod_morph_##NAME);\
            #binding-cells = <0>;\
            bindings = <BINDING_PURE>, <BINDING_MODED>;\
            mods = <(MODS)>;\
         };\
    };\
  };

#define MOD_MORPH_SHIFT(NAME, BINDING_PURE, BINDING_MODED) \
  MOD_MORPH(s_##NAME, BINDING_PURE, BINDING_MODED, MOD_LSFT|MOD_RSFT)

// a high taping-terms value is ok, as REP should be used for repeated key presses
#define TAP_DANCE(NAME, ...) \
/ {\
  behaviors {\
    td_##NAME: tap_dance_##NAME {\
      compatible = "zmk,behavior-tap-dance";\
      label = str(tap_dance_##NAME);\
      #binding-cells = <0>;\
      tapping-term-ms = <200>;\
      bindings = __VA_ARGS__;\
     };\
  };\
};

#define TAP_DANCE_SHIFT(KEY) \
  TAP_DANCE(s_##KEY, <&kp KEY>, <&kp LS(KEY)>)

//      retro-tap;\
// timeless-homerow-mods from UROB: https://github.com/urob/zmk-config#timeless-homerow-mods
//    tapping-term-ms = <280>; ==> trigger hold after these ms - only if HRM one handed
//    hold-trigger-key-positions = HOLD_KEYS; ==> trigger tap if these keys are pressed (so same side rolling doesn't trigger mod)
//    hold-trigger-on-release; ==> delay positional check until key-release

#define HOME_ROW_MOD_BEHAVIOR(NAME, BEHAVIOR, HOLD_KEYS) \
/ {\
  behaviors {\
    hrm_##NAME: home_row_mod_##NAME {\
      compatible = "zmk,behavior-hold-tap";\
      label = str(ht_hrm_##NAME);\
      #binding-cells = <2>;\
      flavor = "balanced";\
      tapping-term-ms = <280>;\
      quick-tap-ms = <175>;\
      require-prior-idle-ms = <150>;\
      bindings = <&kp>, <BEHAVIOR>;\
      hold-trigger-key-positions = HOLD_KEYS;\
      hold-trigger-on-release;\
    };\
  };\
};
#define HOME_ROW_MOD(NAME, HOLD_KEYS) \
  HOME_ROW_MOD_BEHAVIOR(NAME, &kp, HOLD_KEYS)
// left-hand HRMs
  HOME_ROW_MOD(l, RIGHT_SIDE_KEYS)
// right-hand HRMs
  HOME_ROW_MOD(r, LEFT_SIDE_KEYS)

// alternative: RTI as mod key for HRM keys
// #define MOD_MORPH_HRM(NAME, BINDING_PURE, BINDING_MODED) \
//   MOD_MORPH(hrm_##NAME, BINDING_PURE, BINDING_MODED, MOD_RSFT)

// mod-layer, which holds mod keys until exited
// layers/hold_mod.dtsi

/ {\
  behaviors {\
    exit_to_ALP: release_mod_and_leave_layer {
      label = "release_mod_and_leave_layer";
        compatible = "zmk,behavior-macro";
        #binding-cells = <0>;
        wait-ms = <10>;
        tap-ms = <20>;
        bindings =
          <&macro_release &kp LSHIFT>,
          <&macro_release &kp LCTRL>,
          <&macro_release &kp LALT>,
          <&macro_release &kp LCMD>,
          <&macro_tap &macro_ls_to_ALP>;
    };
    alt_tab: alt_tab_enter {
      label = "alt_tab_enter";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      wait-ms = <10>;
      tap-ms = <20>;
      bindings =
        <&macro_press &kp LALT>,
        <&macro_tap &kp TAB &to MOD>;
    };
    cmd_tab: cmd_tab_enter {
      label = "cmd_tab_enter";
      compatible = "zmk,behavior-macro";
      #binding-cells = <0>;
      wait-ms = <10>;
      tap-ms = <20>;
      bindings =
        <&macro_press &kp LCMD>,
        <&macro_tap &kp TAB &to MOD>;
    };
// enters a layer and exits it to ALP (disabling all holded mods, using the MOD layer)
    mo_alp: mo_layer_exit_mod_layer {
      label = str(mo_ALP_exit_mod_layer);
      compatible = "zmk,behavior-macro-one-param";
    	#binding-cells = <1>;
	    wait-ms = <0>;
      tap-ms = <0>;
      bindings =  
            <&macro_param_1to1>,
            <&macro_tap &to MACRO_PLACEHOLDER>,
            <&macro_pause_for_release>,
            <&exit_to_ALP>;
    };
  };
};

//// Layer Switching
// with changing underglow
#define MACRO_mo_LAYER_SWITCH_LED(LAYER, COLOR) \
  / { \
    macros { \
      ls_mo_##LAYER: macro_ls_mo_##LAYER { \
        compatible = "zmk,behavior-macro"; \
        label = str(macro_ls_mo_##LAYER); \
        #binding-cells = <0>; \
        wait-ms = <0>; \
        tap-ms = <10>; \
        bindings \
          = <&macro_press &mo LAYER>\
          , <&macro_tap &rgb_ug RGB_COLOR_HSB(COLOR,100,100)>\
          , <&macro_pause_for_release>\
          , <&macro_release &mo LAYER>\
          , <&macro_tap &rgb_ug RGB_COLOR_HSB(248,100,50)>;\
      };\
    };\
  };

// 
#define MACRO_LAYER_SWITCH_LED(LAYER, COLOR) \
    MACRO(ls_to_##LAYER, &to LAYER &rgb_ug RGB_COLOR_HSB(COLOR,100,100)) \
    MACRO_mo_LAYER_SWITCH_LED(LAYER, COLOR)
//    MACRO(ls_mo_##LAYER, &mo LAYER &rgb_ug RGB_COLOR_HSB(COLOR,100,100)) \
// toggle off would lead to wrong layer color
//   MACRO(ls_tog_##LAYER, &tog LAYER &rgb_ug RGB_COLOR_HSB(COLOR,100,100)) \

MACRO_LAYER_SWITCH_LED(ALP, 248)// Alphabeth characters
MACRO_LAYER_SWITCH_LED(CRD, 276) // Layer for Word Chords
MACRO_LAYER_SWITCH_LED(SYM, 48) // Symboles
MACRO_LAYER_SWITCH_LED(NUM, 38) // Numbers
MACRO_LAYER_SWITCH_LED(CMD, 128) // layer for chording
MACRO_LAYER_SWITCH_LED(FUN, 306) // Function Keys
MACRO_LAYER_SWITCH_LED(DAN, 8) // DANGER!
MACRO_LAYER_SWITCH_LED(LCK, 22) // Lock KB
